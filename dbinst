#!/bin/bash
# -*- coding: utf-8 mode: sh -*- vim:sw=4:sts=4:et:ai:si:sta:fenc=utf-8
MYDIR="$(cd "$(dirname -- "$0")"; pwd)"
"$MYDIR/sbin/runphp" --bs --ue --ci || exit 1
DREMGR="$MYDIR"
source "$DREMGR/sbin/vendor/nulib/base/load.sh" || exit 1
source "$DREMGR/sbin/functions.sh" || exit 1

function _set_composefiles() {
    composefile="$DREMGR/dbinst-docker-compose.yml"
    composefiles=("$composefile")
    composeargs=(-f "$composefile")
    localfile="$DREMGR/dbinst-docker-compose.local.yml"
    if [ -f "$localfile" ]; then
        composefiles+=("$localfile")
        composeargs+=(-f "$localfile")
    fi
}

function start_dbinst() {
     local composefile localfile; local -a composefiles composeargs
    _set_composefiles

    [ -f "$composefile" ] || die "$composefile: fichier introuvable"
    if [ -n "$ForceStart" ]; then
        :
    elif dcrunning "${composefiles[@]}"; then
        enote "DRE [$Profile] est démarré"
        return
    fi

    "$DREMGR/build" ${Rebuild:+--rebuild} || die

    local -a pgconfs; local pgconf
    pgconfs=(
        "$DREMGR/${Profile}_postgresql.conf"
        "$DREMGR/config/postgres/postgresql.conf"
    )
    for pgconf in "${pgconfs[@]}"; do
        [ -f "$pgconf" ] && break
    done

    estep "Démarrage de DRE [$Profile]"
    local dredata="$DATADIR/${Profile}-dredata"
    rsync -Lpt "$Envfile" "$dredata/profile.env"
    rsync -Lptr "$DREMGR/config/cron/" "$dredata/cron-config/"
    rsync -Lpt "$pgconf" "$dredata/postgresql.conf"
    docker compose "${composeargs[@]}" up -d --wait ${Recreate:+--force-recreate} || die
}

function stop_dbinst() {
     local composefile localfile; local -a composefiles composeargs
    _set_composefiles

    [ -f "$composefile" ] || return 0
    if dcrunning "${composefiles[@]}"; then
        estep "Arrêt de DRE [$Profile]"
        docker compose "${composeargs[@]}" down || die
    fi
}

function refresh_dbinst() {
    local ForceStart=1
    start_dbinst "$@"
}

function restart_dbinst() {
    local ForceStart=1
    local Recreate=1
    start_dbinst "$@"
}

function import_dumps() {
     local composefile localfile; local -a composefiles composeargs
    _set_composefiles

    [ -f "$composefile" ] || return 0
    if dcrunning "${composefiles[@]}"; then
        estep "Import des dumps [$Profile]"
        docker compose "${composeargs[@]}" exec cron import-dumps "$@" || die
    else
        eerror "Impossible d'importer les dumps: DRE [$Profile] est arrêté"
    fi
}

function import_one() {
    local name="$1"; shift
    [ -n "$name" ] || die "Vous devez spécifier le nom de l'addon à importer"

    import_dumps -@ latest --runao -o "$name" --notifao "$@"
}

function import_one_devel() {
    local srcdir="$1"; shift
    [ -n "$srcdir" ] || die "Vous devez spécifier le répertoire source de l'addon à importer"
    [ -d "$srcdir" ] || die "$srcdir: répertoire d'addon introuvable"
    setx srcdir=abspath "$srcdir"

    local name="$(basename "$srcdir")"
    local importlog="$DREMGR/var/${Profile}-dredata/import.log"
    local destdir="$DREMGR/var/${Profile}-dredata/addons/$name"

    if [ "$srcdir" != "$DREMGR" -a "${srcdir#$DREMGR/}" == "$srcdir" ]; then
        estep "Copie des fichiers vers ${destdir#$DREMGR/}"
        [ "$(id -u)" == 0 ] && sudo= || sudo=sudo
        $sudo rsync -rlp --delete -f "- /.git/" -f "P /.git/" "$srcdir/" "$destdir/" || die
    fi

    import_dumps --clean-import-log -@ latest --no-updateao --runao -o "$name" --notifao "$@"

    less -eF "$importlog"
}

function psql_prompt() {
     local composefile localfile; local -a composefiles composeargs
    _set_composefiles

    [ -f "$composefile" ] || return 0
    if dcrunning "${composefiles[@]}"; then
        estep "Invite psql [$Profile]"
        docker compose "${composeargs[@]}" exec db psql "$@" || die
    else
        eerror "Impossible de lancer l'invite psql: DRE [$Profile] est arrêté"
    fi
}

function shell_prompt() {
     local composefile localfile; local -a composefiles composeargs
    _set_composefiles

    [ -f "$composefile" ] || return 0
    if dcrunning "${composefiles[@]}"; then
        local container="$1"; shift
        local -a cmd
        if [ $# -gt 0 ]; then
            cmd=("$@")
            estep "$container [$Profile] $1"
        else
            cmd=(bash)
            estep "$container [$Profile] Invite shell"
        fi
        docker compose "${composeargs[@]}" exec "$container" "${cmd[@]}" || die
    else
        eerror "Impossible de lancer l'invite shell $container: DRE [$Profile] est arrêté"
    fi
}

function write_output() {
    if [[ "$1" == *.gz ]]; then
        gzip -c >"$1"
    else
        cat >"$1"
    fi
}

function backup_db() {
    local composefile localfile; local -a composefiles composeargs
    _set_composefiles
    [ -f "$composefile" ] || return 0

    local dbname="$1" output="$2"
    [ -n "$dbname" ] || dbname=pdata
    [ -n "$output" ] || output="${Profile}_${dbname}-$(date +%y%m%d).sql.gz"

    if dcrunning "${composefiles[@]}"; then
        local -a cmd
        estep "[$Profile] Sauvegarde $dbname vers $output"
        cmd=(pg_dump -c -C -Fp -O --if-exists -d "$dbname")
        docker compose "${composeargs[@]}" exec db "${cmd[@]}" |
            write_output "$output" || die "Une erreur s'est produite pendant la sauvegarde"
    else
        eerror "Impossible de sauvegarder $dbname: DRE [$Profile] est arrêté"
    fi
}

function read_input() {
    if [[ "$1" == *.gz ]]; then
        gzip -dc "$1"
    else
        cat "$1"
    fi
}

function restore_db() {
    local composefile localfile; local -a composefiles composeargs
    _set_composefiles
    [ -f "$composefile" ] || return 0

    local input="$1" dbname="$2"
    [ -n "$input" ] || die "Vous devez spécifier le fichier à restaurer"
    [ -f "$input" ] || die "$input: fichier introuvable"
    [ -n "$dbname" ] || dbname=pdata

    if dcrunning "${composefiles[@]}"; then
        local -a cmd
        eimportant "[$Profile] Restauration $dbname depuis $input"
        ask_yesno "Voulez-vous continuer?" O || die

        estep "Terminaison de toutes les connections en cours"
        cmd=(psql -c "select pg_terminate_backend(pid) from pg_stat_activity where datname='$dbname'")
        docker compose "${composeargs[@]}" exec db "${cmd[@]}"

        estep "Restauration de la base de données"
        cmd=(psql)
        read_input "$input" |
            docker compose "${composeargs[@]}" exec -T db "${cmd[@]}" || die "Une erreur s'est produite pendant la restauration"

    else
        eerror "Impossible de restaurer $dbname: DRE [$Profile] est arrêté"
    fi
}

case "$MYNAME" in
*_dbinst) Profile="${MYNAME%_dbinst}";;
*)
    Profile=prod
    load_envs APP_PROFILES
    if [ -n "$APP_PROFILES" ]; then
        read -a profiles <<<"${APP_PROFILES//
/ }"
        Profile="${profiles[0]}"
    fi
    ;;
esac

ForceStart=
Recreate=
action=auto
Rebuild=
args=(
    "Gérer cette instance de DRE"
    #"usage"
    --check-only action=none "++Ne faire que la vérification de l'environnement"
    -g:,--profile:PROFILE Profile= "\
++Spécifier le profil. La valeur par défaut est $Profile"
    -A,--all-profiles Profile=ALL "++Faire l'opération pour tous les profils définis dans dremgr.env"
    -P,--prod Profile=prod "++alias pour --profile prod"
    -T,--test Profile=test "++alias pour --profile test"
    -s,--start action=start "Démarrer DRE"
    -k,--stop action=stop "Arrêter DRE"
    -r,--refresh action=refresh "(Re)démarrer DRE si nécessaire"
    -R,--restart action=restart "Forcer le (re)démarrage de DRE"
    -b,-B,--rebuild Rebuild=1 "++Forcer le rebuild de l'image avant le démarrage"
    -i,--import-all action=import_all "Lancer l'import complet maintenant, sans attendre la planification"
    -I,--import-one action=import_one "++\
Lancer l'import d'un unique addon sans attendre la planification
- soit la commande suivante:
    $MYNAME -I DREADDON
- l'addon est importé comme avec les options suivantes:
    $MYNAME -i -- --runao -o DREADDON \"\$@\"
cf la documentation pour les détails"
    -J,--import-one-devel action=import_one_devel "++\
Importer un addon en mode développement:
- Soit la commande suivante:
    $MYNAME -J path/to/DREADDON
- le contenu du répertoire de l'addon est synchronisé vers le répertoire correspondant du conteneur
- puis l'addon est importé comme avec les options suivantes:
    $MYNAME -i -- --no-updateao --runao -o DREADDON \"\$@\"
  cf la documentation pour les détails"
    -q,--psql action=psql "Lancer une invite psql connecté avec le compte administrateur"
    --shell-db action=shell_db "++Lancer une invite bash dans le container db"
    --show-conf action=show_conf "++Afficher la configuration postgresql.conf"
    -x,--shell-cron action=shell_cron "++Lancer une invite bash dans le container cron"
    --backup action=backup "++\
Sauvegarder la base de données. Il faut préciser en argument [db [output]]
db est le nom de la base de données à sauvegarer et vaut par défaut pdata
output est le fichier en sortie et vaut par défaut <PROFILE>_<DB>-YYmmdd.sql.gz"
    --restore action=restore "++\
Restaurer la base de données. Il faut préciser en argument [input [db]]
input est le fichier en entrée
db est le nom de la base de données à restaurer et vaut par défaut pdata"
)
parse_args "$@"; set -- "${args[@]}"

# pour des raisons pratiques, --profile peut désigner le fichier de
# configuration
Profile="${Profile##*/}"
Profile="${Profile%_profile.env}"

IS_DBINST=1
run_check_env || exit 22

setx Envfile=get_envfile
[ -f "$Envfile" ] || die "$(ppath "$Envfile"): fichier introuvable"
load_envs APP_PROFILES APP_PROFILES_AUTO DATADIR
[ -n "$APP_PROFILES" ] || die "Aucun profil n'est défini"

if [ "$Profile" == ALL ]; then
    Profile=

    args=(
        ${Rebuild:+--rebuild}
    )
    case "$action" in
    none) args+=(--check-only);;
    auto) ;;
    *) args+=("--${action//_/-}");;
    esac

    case "$action" in
    import_*) app_profiles="$APP_PROFILES_AUTO";;
    psql|shell_*) app_profiles="$APP_PROFILES_AUTO";;
    esac
    [ -n "$app_profiles" ] || app_profiles="$APP_PROFILES"
    read -a profiles <<<"${app_profiles//
/ }"
    for profile in "${profiles[@]}"; do
        etitle "$profile"
        "$MYSELF" --profile "$profile" "${args[@]}" -- "$@"; r=$?
        [ $r -eq 22 ] && exit
        eend
    done
    exit
fi

[ "$action" == auto ] && action=start
[ "$action" == none ] && exit 0

ensure_dirs

case "$action" in
start) start_dbinst "$@";;
stop) stop_dbinst "$@";;
refresh) refresh_dbinst "$@";;
restart) restart_dbinst "$@";;
import_all) import_dumps "$@";;
import_one) import_one "$@";;
import_one_devel) import_one_devel "$@";;
psql) psql_prompt "$@";;
shell_*) shell_prompt "${action#shell_}" "$@";;
show_conf) shell_prompt db show-conf.sh;;
backup) backup_db "$@";;
restore) restore_db "$@";;
*) die "$action: action non implémentée";;
esac
