#!/bin/bash
# -*- coding: utf-8 mode: sh -*- vim:sw=4:sts=4:et:ai:si:sta:fenc=utf-8
MYDIR="$(cd "$(dirname -- "$0")"; pwd)"
MYNAME="$(basename -- "$0")"
MYSELF="$MYDIR/$MYNAME"
DREMGR="${MYDIR%/*}"

function eecho() { echo "$*" 1>&2; }
function eerror() { eecho "ERROR: $*"; }
function die() { [ $# -gt 0 ] && eerror "$*"; exit 1; }

if [ -z "$_RUNDK_IN_DOCKER" ]; then
    ################################################################################
    # Charger ~/.dkbuild.env

    APT_PROXY="$DREMGR_APT_PROXY"
    APT_MIRROR="$DREMGR_APT_MIRROR"
    SEC_MIRROR="$DREMGR_SEC_MIRROR"
    TIMEZONE="$DREMGR_TIMEZONE"
    PRIVAREG="$DREMGR_PRIVAREG"
    REGISTRY="$DREMGR_REGISTRY"
    IMAGE="$DREMGR_IMAGE"
    PROFILE=
    HOST_MAPPINGS=()
    function default_profile() {
        PROFILE="$1"
    }
    function profile() {
        local profile
        for profile in "$@"; do
            [ "$profile" == "$PROFILE" ] && return 0
        done
        return 1
    }
    function setenv() {
        eval "export $1"
    }
    function default() {
        local command="$1"; shift
        local nv n v
        case "$command" in
        docker)
            for nv in "$@"; do
                [[ "$nv" == *=* ]] || continue
                n="${nv%%=*}"
                v="${nv#*=}"
                case "$n" in
                host-mappings)
                    read -a ns <<<"$v"
                    for v in "${ns[@]}"; do
                        HOST_MAPPINGS+=("$v")
                    done
                    ;;
                esac
            done
            ;;
        esac
    }
    [ -f ~/.dkbuild.env ] && source ~/.dkbuild.env

    [ -n "$APT_PROXY" ] || APT_PROXY=
    [ -n "$APT_MIRROR" ] || APT_MIRROR=default
    [ -n "$SEC_MIRROR" ] || SEC_MIRROR=default
    [ -n "$TIMEZONE" ] || TIMEZONE=Europe/Paris
    [ -n "$PRIVAREG" ] || PRIVAREG=
    [ -n "$REGISTRY" ] || REGISTRY=pubdocker.univ-reunion.fr

    ################################################################################
    # Lancer la commande depuis l'extérieur du container

    BUILD_ARGS=(
        REGISTRY
        APT_PROXY
        APT_MIRROR
        SEC_MIRROR
        TIMEZONE
    )

    SOPTS=+0jDc:x:z:r:pw:v
    LOPTS=help,build,no-cache,plain-output,config:,apt-proxy:,timezone:,privareg:,push,chdir:,verbose,no-use-rslave
    args="$(getopt -n rundk -o "$SOPTS" -l "$LOPTS" -- "$@")" || exit 1; eval "set -- $args"

    Build=
    NoCache=
    PlainOutput=
    Chdir=
    Verbose=
    if [ -n "$DREMGR_NO_USE_RSLAVE" ]; then
        UseRslave=
    elif [ -n "$DREMGR_USE_RSLAVE" ]; then
        UseRslave=1
    elif [ -e /proc/sys/fs/binfmt_misc/WSLInterop ]; then
        # pas de mount propagation sous WSL
        UseRslave=
    else
        UseRslave=1
    fi
    while [ $# -gt 0 ]; do
        case "$1" in
        --) shift; break;;
        --help)
            eecho "\
rundk: lancer une commande dans docker

avant de lancer la commande, le répertoire courant est systématiquement modifié
pour être celui de dremgr.

USAGE
    $MYNAME command [args...]

OPTIONS
    -0, --build
    -j, --no-cache
    -D, --plain-output
    -c, --config build.env
    -x, --apt-proxy APT_PROXY
    -z, --timezone TIMEZONE
    -r, --privareg PRIVAREG
    -p, --push
        construire l'image rundk en local au lieu de la télécharger
    -w, --chdir CHDIR
        aller dans le répertoire spécifié avant de lancer la commande. si le
        répertoire est relatif, il est exprimé par rapport au répertoire de
        dremgr
    -v, --verbose
        afficher plus d'informations"
            exit 0
            ;;
        -0|--build) Build=1;;
        -j|--no-cache) NoCache=1;;
        -D|--plain-output) PlainOutput=1;;
        -c|--config) shift; Config="$1";;
        -x|--apt-proxy) shift; APT_PROXY="$1";;
        -z|--timezone) shift; TIMEZONE="$1";;
        -r|--privareg) shift; PRIVAREG="$1";;
        -p|--push) Push=1;;
        -w|--chdir) shift; Chdir="$1";;
        -v|--verbose) Verbose=1;;
        --no-use-rslave) UseRslave=;;
        *) die "$1: option non configurée";;
        esac
        shift
    done

    if [ -z "$IMAGE" ]; then
        IMAGE=dremgr/rundk
        [ -n "$PRIVAREG" ] && IMAGE="$PRIVAREG/$IMAGE" || IMAGE="$REGISTRY/$IMAGE"
    fi
    if [ -n "$Build" ]; then
        if [ -n "$Config" ]; then
            source "$Config" || exit 1
        fi
        args=(
            -f "$MYDIR/Dockerfile.tools"
            ${NoCache:+--no-cache}
            ${BuildPlain:+--progress plain}
            -t "$IMAGE"
        )
        for arg in "${BUILD_ARGS[@]}"; do
            args+=(--build-arg "$arg=${!arg}")
        done
        mkdir -p /tmp/rundk
        docker build "${args[@]}" /tmp/rundk || exit 1
        if [ -n "$Push" -a -n "$PRIVAREG" ]; then
            docker push "$IMAGE" || exit 1
        fi
        exit 0
    fi

    uid="$(id -u)"
    gid="$(id -g)"
    args=(
        run -it --rm
        --name dremgr-rundk
        -e _RUNDK_IN_DOCKER=1
        -e _RUNDK_UID="$uid"
        -e _RUNDK_GID="$gid"
    )
    for host in "${HOST_MAPPINGS[@]}"; do
        args+=(--add-host "$host")
    done

    # monter le répertoire qui contient $DREMGR
    mount_composer=
    if [ "${DREMGR#$HOME/}" != "$DREMGR" -o "$DREMGR" == "$HOME" ]; then
        # bind mount /home
        args+=(-v "$HOME:$HOME${UseRslave:+:rslave}" -w "$DREMGR")
        mounted_home=1
    else
        # bind mount dremgr
        args+=(-v "$DREMGR:/rundk" -w /rundk)
        mount_composer=1
    fi
    if [ $uid -eq 0 -a -n "$mount_composer" -a -d "$HOME/.composer" ]; then
        # si c'est root, monter la configuration de composer
        args+=(-v "$HOME/.composer:/root/.composer")
    fi

    # lancer avec l'utilisateur courant
    if [ $uid -ne 0 ]; then
        # si c'est un utilisateur lambda, il faut monter les informations
        # nécessaires. composer est déjà monté via $HOME
        user="$(id -un)"
        userent="$(getent passwd "$user")"
        group="$(id -gn)"
        groupent="$(getent group "$group")"
        args+=(
            -e _RUNDK_USER="$user"
            -e _RUNDK_USERENT="$userent"
            -e _RUNDK_GROUPENT="$groupent"
        )
    fi

    args+=(
        "$IMAGE"
        exec "$MYSELF" -w "$Chdir"
    )
    [ -n "$Verbose" ] && eecho "\$ docker ${args[*]} $*"
    exec docker "${args[@]}" "$@"

else
    # Ajouter les informations utilisateur le cas échéant
    if [ -n "$_RUNDK_USERENT" ]; then
        grep -q "^$_RUNDK_USER:" /etc/passwd || echo "$_RUNDK_USERENT" >>/etc/passwd
    fi
    if [ -n "$_RUNDK_GROUPENT" ]; then
        grep -q "^$_RUNDK_GROUP:" /etc/group || echo "$_RUNDK_GROUPENT" >>/etc/group
    fi
    if [ -n "$_RUNDK_USER" ]; then
        user="$_RUNDK_USER"
        export _RUNDK_USER=
        export _RUNDK_USERENT=
        export _RUNDK_GROUPENT=
        exec su-exec "$user" "$0" "$@"
    fi

    # Lancement depuis l'intérieur du container
    SOPTS=+w:
    LOPTS=chdir:
    args="$(getopt -n "$MYNAME" -o "$SOPTS" -l "$LOPTS" -- "$@")" || exit 1; eval "set -- $args"

    Chdir=
    while [ $# -gt 0 ]; do
        case "$1" in
        --) shift; break;;
        -w|--chdir) shift; Chdir="$1";;
        *) die "$1: option non configurée";;
        esac
        shift
    done

    if [ -n "$Chdir" ]; then
        cd "$Chdir" || die
    fi
    "${@:-bash}"
fi
